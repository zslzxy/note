# JVM虚拟机笔记

## 命令

- **-XX:+HeapDumpOnOutOfMemoryError**  生成对应的OutOfMemory对应的Dump文件，生成对应的.hprof文件存放在该项目的根目录。
- **-XX:+HeapDumpOnCtrlBreak**  能够使用 Ctrl+Break 快捷键生成对应的dump文件。
- **-Xms20m  -Xmx20m**   指定对应的虚拟机堆内存大小。
- **-Xss128k**   指定虚拟机栈的内存大小。由于HotSpot虚拟机的虚拟机栈与本地方法栈是一起的，所以可以一起设置。
- **-Xoss128k**  指定本地方法栈的内存大小，在HotSpot虚拟机中无效。
- **-XX:PermSize=10M**  指定虚拟机方法区的大小。
- **-XX:MaxPermSize=20m**   指定虚拟机方法区的最大值。
- **-XX:+PrintGC**   输出GC日志
- **-XX:+PrintGCDetails**   输出GC详细日志
- **-XX:+PrintHeapAtGC**   在进行GC前后打印出堆信息
- **-Xmn10M**   设置年轻代的大小
- **-XX:SurvivorRatio=8**   设置新生代中Eden区与Survivor区的比例为8:1.
- **-XX:MaxPermSize=16m**   设置持久带大小为16m。
- **-XX:PretenureSizeThreshold=3145782**   设置大对象的阈值。

- **-XX:MaxTenuringThreshold=15**   设置对象年龄计数器，当对象的年龄超过了这个值仍然存活，则进入老年代。
- **-XX:+PrintFlagsFinal**  打印对应的java的虚拟机默认参数。



## 工具

### 1. Eclipse Memory Analyzer

下载地址：

- https://www.eclipse.org/mat/

> ​	使用Eclipse Memory Analyzer工具能够对java虚拟机生成的Dump文件进行解析操作。





## 1 对象管理

### 1.1 对象的创建

> ​	java是专注于面向对象的语言，无时无刻都存在着对象的创建。

#### 1.1.1 创建步骤

- 检查new指令对应的类是否已经被加载解析和初始化。
- 类加载检查通过以后，即可确定对象创建所需的内存。
- 为对象分配内存空间：
  - 采用**`指针碰撞`**：虚拟机内存的占用是规整的，采用指针来作为分界线，当创建新的对象时，直接将对应的指针进行挪动对应的距离。
  - 采用**`空闲列表`**：虚拟机的内存占用是不规整的，维护一个对应的列表，记录哪一些内存块是可用的，在可分配的列表中找到足够大内存空间划分给对象实例。
- 内存分配完成，虚拟机需要将分配的的内存空间对象都进行初始化值的赋值，即赋值为零值。
- 虚拟机需要对对象进行必要的设置，包括对象所属实例、对象的元数据信息、对象的哈希码等等。该数据都存放在**对象头**中进行存储。
- 虚拟机基础工作完成，一个新的对象已经产生。但是从java角度来看，对象的创建才刚刚开始——<init> 方法还未执行，所有的字段还是零值。所以，执行new指令之后需要接着执行<init>方法，把对象按照代码的值进行初始化赋值，即可完成对象的创建工作。

#### 1.1.2 安全限制

> ​	在创建虚拟机的过程中，多线程频繁创建对象实例，则线程安全操作需要设置。
>
> - 采用**指针碰撞**的方式，就是修改对应的指针位置，那么需要采用CAS算法配置上失败重试的方式保证更新操作的原子性。
> - 采用**空闲列表**的方式，则可以把内存分配的动作按照线程划分在不同的空间之中进行，即每一个线程在java堆中预先分配一块小内存空间，称为本地线程分配缓冲（Threead Local Allocation Buffer，TLAB）。对应的线程在对应的TLAB中完成分配以后，才需要对内存进行同步锁定。

### 1.2 对象的内存布局

> ​	对象在内存中存储的布局主要分为3块区域：
>
> - **对象头（Header）**：对象头主要包含两部分信息
>   - 第一部分：存储对象自身的运行时数据，包括哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。该部分数据在32位与64位虚拟机中分别占用32bit与64bit，官方简称：**Mark Word**。
>   - 第二部分：存储的是类型指针，即对象指向它的类元数据的指针，虚拟机通过该这个指针来确定这个独享是哪一个类的实例。
> - **实例数据（Instance Data）**
> - **对齐填充（Padding）**

### 1.3 对象的访问定位

> ​	Java程序主要是通过栈上面的reference数据来操作堆中的具体对象。**通常情况下，对象访问方式采用的是`句柄`和`直接指针`两种。**
>
> - **`句柄`**：java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址。
>
> ![1558254701724](assets/1558254701724.png)
>
> - **`直接指针`**：java的reference中存储的直接就是对象地址。
>
> ![1558254801052](assets/1558254801052.png)
>
> ​	句柄的最大优势在于reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而不是修改reference本身。
>
> ​	直接指针访问的优势在于访问速度更快，节省了一次指针定位的时间开销工作。HotSpot虚拟机采用的是直接指针方式。

## 2 内存管理

### 2.1 Java堆溢出

> ​	Java堆用于存储对象实例，只要不断的创建对象，并且保证GC Roots到对象之间有科大路径来避免垃圾回收机制清楚这些对象，那么在对象数据到达最大堆的容量限制以后就会产生内存溢出异常。

```java
	public static void main(String[] args) {
		List<Demo> list = new ArrayList<>();
		while(true) {
			list.add(new Demo());
		}
	}
```

​	抛出异常java.lang.OutOfMemoryError，并且后面跟随这个 Java heap space。通常采用的是Eclipse Memory Amalyzer打开存储快照hprof文件进行分析。

### 2.2 虚拟机栈、本地方法栈溢出

> ​	虚拟机栈与本地方法栈溢出主要分为：
>
> - 如果线程请求的栈深度大于虚拟机所允许的最大深度，则抛出StackOverFlowError。
> - 如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError。

```java
package com.zsl.test2;

public class JconsoleTest {

	public static void main(String[] args) {
//		JavaVMStackSOF jcss = new JavaVMStackSOF();
//		jcss.stackLeak();
		JavaVMStackOOM jvom = new JavaVMStackOOM();
		jvom.stackLeakByThread();
	}
	
}

/**
 * Stack对应的StackOverFlowError
 * @author 10838
 *
 */
class JavaVMStackSOF {
	private int stackLength = 1;
	public void stackLeak() {
		stackLength++;
		stackLeak();
	}
}

/**
 * Stack对应的OutOfMemoryError
 * @author 10838
 *
 */
class JavaVMStackOOM {
	private void dontStop() {
		while(true) {
			
		}
	}
	public void stackLeakByThread() {
		while (true) {
			Thread thread = new Thread(new Runnable() {
				@Override
				public void run() {
					dontStop();
				}
			});
			thread.start();
		}
	}
}
```

### 2.3 方法区溢出

> ​	运行时常量池也是方法区的一部分，将字符串常量池溢出工作，能够测试出对应的异常数据。方法区主要是存储Class的相关数据结构，其中包括了类名、访问修饰符、常量池、字段描述、方法描述等数据。

```java
public class RuntimeConstantPoolOOM {

	public static void main(String[] args) {
		List<String> list = new ArrayList<>();
		int i = 0;
		while (true) {
			list.add(String.valueOf(i++).intern());
		}
	}
}
```

​	出现异常：java.lang.OutOfMemoryError：PerGen space，也就是通常情况下的方法区溢出。

## 3 垃圾收集器

### 3.1 垃圾回收算法

#### 3.1.1 引用计数算法

> **简介：**给对象添加一个引用计数器，当对象存在一个地方引用它时，计数器的值就加1；当对象引用失效时，计数器的值减1；当引用计数器为0的时刻，表明该对象已经没有被其他对象所引用了，可以进行垃圾回收GC的操作。
>
> **缺陷：**当两个对象之间相互引用，但是两个对象都已经没有被其他对象所引用了，则垃圾收集器也不会对其进行GC操作，导致内存泄漏。市场中主流的JVM未使用该方法。

#### 3.1.2 可达性分析算法

> **简介：**通过一系列可达性分析（Reachability Analysis）来判定对象是否存活的。这个算法的基本思想是通过一系列称为 **`GC Roots`** 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为**引用链**，当一个对象GC Roots没有任何引用链相连，则表示该对象不可达，那么即可将其进行GC操作。
>
> **GC Roots对象：**
>
> - 虚拟机栈（栈帧中的本地变量表）中引用的对象。
> - 方法区中类静态属性引用的对象。
> - 方法区中常量引用的对象。
> - 本地方法栈JNI（即一般说的Native方法）引用的对象。

### 3.2 对象死亡过程

​	对finalize()方法的深刻理解，以及进行GC的整个流程操作如下：

> ​	当对象使用无引用或不可达时，其死亡过程还需要经历**两次标记过程：如果对象在进行可达性分析后发现没有GC Roots相连接的引用链，则它将会被`第一次标记`并且进行一次筛选，筛选的条件是对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，则虚拟机将这两种情况都视为“没有必要执行”。**
>
> ​	**当对象被判定为有必要执行finalize()方法，则会将该对象加入到一个叫做`F-Queue`的队列中，并在稍后由虚拟机自动创建一个低级Finalizer线程去执行finalize()方法。**
>
> ​	**finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue只能够的独享进行`第二次小规模的标记`操作，如果对象在finalize()方法中成功拯救了自己——重新与引用链中的一个对象相关联，则会在第二次标记的时候被移除出“即将回收”的集合中；如果对象未能够成功自救，则对象会被回收。**
>
> ​	**对象的finalize()方法最多只能够被调用一次，也就是说对象在第一次GC的时候调用了finalize()方法并成功自救，那么第二次进行GC操作的时候，就不会再次执行finalize()方法，直接进行GC回收操作。**

### 3.3 方法区回收

​	通常情况下，对方法区进行垃圾回收操作效率较低。方法区永久带主要的垃圾回收包括：**`废弃常量`以及`无用的类`**。

- **回收废弃常量**：当常量池中存在对应的字符串“ABC”，却没有对饮的String对象对字符串字面量“ABC”进行引用，则需要进行内存回收操作，将“ABC”常量进行清除操作。

- **回收无用的类**：判断无用的类的条件如下：

  - 该类的所有实例都已经被回收，也就是在Java队中不存在该类的任何实例。
  - 加载该类的ClassLoader已经被回收。
  - 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

  当类具备上诉条件，则该无用类即可进行回收操作。

### 3.4 垃圾回收算法

#### 3.4.1 标记-清除算法

> **原理：**首先标记所有需要被回收的对象，在标记完成以后统一回收已经被标记了的对象。
>
> **缺陷：**
>
> - 效率低，标记与清除两个过程的效率较低；
> - 标记清除算法容易产生大量不连续的内存碎片，空间碎片太多导致分配大内存对象时无法找到对应的内存空间。

![1558315080516](assets/1558315080516.png)

#### 3.4.2 标记-复制算法

> **原理：**将内存按照容量划分为大小相等的两块，当一块内存使用完毕，将存活的对象复制到另外一块上面，然后再将已经使用过的内存空间直接全部清理。
>
> **实现方式：**在商业虚拟机中，并非是按照1:1的比例进行比较，而是将JVM内存划分为  一块较大的Eden空间以及两块较小的Survivor区域  ，每次使用Eden和其中一块Survivor区。当进行回收操作时，将正在使用的Eden区和Survivor区中存活的对象一次性的复制到另外一块Survivor区中，最后清除掉已经使用的Eden和Survivor区域。
>
> **HotSpot实现方式：** HotSpot虚拟机针对Eden区域与Survivor区域的比例是： 8:1:1，所以每一次垃圾回收操作只会有10%的内存会被浪费掉。当Survivor区域无法存储所有存活的对象，则使用其他内存（老龄代）进行分配担保。
>
> **优势：**
>
> - 直接对一块内存进行全部清理工作，能够有效地避免内存碎片等复杂情况。
>
> **劣势：**
>
> - 将内存划分为两块，内存利用效率变得比较低。
> - 在对象存活率较高的区域采用标记-复制算法，效率更低。

![1558317147723](assets/1558317147723.png)

#### 3.4.3 标记-整理算法

> **原理：** 针对需要进行垃圾回收操作的对象，首先对其进行标记，后续步骤是将所有存活的对象都向一端进行移动，然后直接清理掉端边界以外的内存。

![1558317409177](assets/1558317409177.png)

#### 3.4.4 分代收集算法

> ​	当前商业虚拟机都采用的是“分代收集”算法，这种算法是根据对象存活周期的不同将内存划分为几块。通常在java中根据新生代老龄代分别选择不同的垃圾算法。
>
> - 新生代垃圾收集算法：主要是针对大量对象的存活效率低，大批对象的死去，采用标记-复制算法，效率较高。
> - 老龄代垃圾收集算法：老龄代中对象的存活率高，没有额外空间对其进行分配担保，可以采用标记-清理/整理算法。

#### 3.4.5 GC术语

>**`Minor GC---新生代GC`**：指发生在新生代的垃圾收集动作，因为java大多数对象具有朝生夕死的特征，所以Minor GC非常频繁，一般回收速度较快。
>
>**`Major/Full GC`**：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC操作，Major GC发生速度一般比Minor GC速度更慢。

#### 3.4.6 大对象进入老龄代

> ​	所谓的大对象，就是需要大量连续内存空间的Java对象，对典型的就是数组大对象。通常情况下，是根据JVM设定的大对象的最小值进行比较，当对象大于设定的值，则直接对大对象进入老龄代。
>
> **命令：**使用 **`-XX:PertenureSizeThreshold=3145728`** 设置大对象的阈值。

#### 3.4.7 长期存活对象进入老龄代

> ​	虚拟机采用分代收集的思想来管理内存空间。针对对象设置对象年龄数据，当对象在Survivor中熬过了设置的年龄值，则进入到老龄代。在Survivor中熬过一次，则年龄加1.
>
> 命令：使用**`-MaxTenuringThreshold=15`**来设置晋升老龄代的阈值。

#### 3.4.8 动态对象年龄判定

> ​	根据不同程序的内存状况，虚拟机并不是永远的要求对象年龄必须达到MaxTenuringThreshold才能晋升老龄代，**当Survivor区中相同年龄的对象所占内存超出Survivor区中的一半，则Survivor中大于等于该年龄的对象就可以直接进入到老年代**。

## 4 JVM监控、故障处理

### 4.1 命令行工具

#### 4.1.1 jps——虚拟机进程状况工具

> **简介：** jps（JVM Process Status Tool），其主要作用是列出正在运行的虚拟机进程，并显示`虚拟机执行主类（Main Class，也就是main()方法所在的类）的名称`以及该进程的`本地虚拟机唯一ID（Local Virtual Machine Identifier，LVMID）`。
>
> **命令：** `jps  [options]  [hostid]`
>
> **选项：**
>
> - -q：只输出LVMID，省略主类的名称。
> - -m：输出虚拟机进程启动时传递主类main()函数的参数。
> - -l：输出主类的全名，如果进程执行的是Jar包，则输出Jar路径。
> - -v：输出虚拟机进程启动时JVM参数。
>
> **例如：** jps   查看正在运行的java虚拟机进程。

#### 4.1.2 jstat——虚拟机统计信息监视工具

> **简介：** jstat（JVM Statistics Monitoring Tool），是用于监视虚拟机各种运行状态信息的命令行工具。主要显示的四本地或者远程虚拟机进程中的`类装载、内存、垃圾收集、JIT编译等运行数据`，无GUI图形界面，只提供了纯文本控制台环境的服务器，它将是运行期定位虚拟机性能问题的首选工具。
>
> **命令：** `jstat [option vmid [interval[s|ms] [count]] ]`
>
> **解释：**
>
> - option：表示的是对应的虚拟机操作，例如GC操作
>   - -class：监视类装载、卸载数量、总空间以及类装载所耗费时间。
>   - -gc：监视java的gc堆状况，新生区、老年区、永久带等容量、GC时间合计等数据。
>   - -gccapacity：监视gc堆状况，主要是输出java堆中各个区域使用到的最大、最小空间。
>   - -gcutil：监视gc操作，主要是输出关注已经使用空间占总空间的百分比。
>   - -gcnew：监视新生代GC状况。
>   - -gcnewcapacity：监视新生代的最大、最小空间。
>   - -gcode：监视老年代GC状况。
>   - -gcodecapacity：监视老年代GC状况的最大、最小空间。
>   - -gcpermcapacity：输出永久带使用到的最大、最小空间。
>   - -complier：输出JIT编译器编译过的方法、耗时等信息。
>   - -printcompliation：输出已经被JIT编译的方法。
>
> - vmid：表示的是虚拟进程id
> - interval：表示的是查询间隔，可以省略，默认是采用ms作为时间单位。
> - count：表示的是查询的次数，默认值为1，可以省略
>
> **例如：** jstat  -gc  2764  250  20  表示的是针对2764的垃圾收集状况进行每隔250ms查询一次，总共查询20次

#### 4.1.3 jinfo——java配置信息工具

> **简介：**jinfo（Configuration Info for Java）的作用是实时地查看和调用虚拟机各项参数。
>
> **命令：** `jinfo [option] pid`
>
> **option：**
>
> - -flag
>
> **例如：** jinfo  -flag  CMSInitiatingOccupancyFraction  1444  查询对应的参数值

#### 4.1.4 jmap——java内存印像工具

> **简介：**jmap（memory Map for Java）命令是用于生成`堆转储快照`（通常称为heapdump或者dump文件）。其他作用包括：`查询finalize执行队列，java堆和永久带详细信息`。
>
> **命令：** jmap  [option]  vmid  
>
> **解释：**
>
> - option：参数的选择
>   - -dump：生成java堆转储快照，格式为：  -dump:format=b,file=<filename>
>   - -finalizerinfo：显示F-Queue中等待Finalizer线程执行finalize方法的对象，只在linux平台开放
>   - -heap：显示java堆详细信息，如使用哪种回收器、参数配置、分代状况等
>   - -histo：显示堆中对象统计信息、包括类、实例数量、合计容量等
>   - -permstat：一ClassLoader为统计口激动显示永久带状态。
>   - -F：强制生成对应的dump快照。
> - vmid：java的jvm虚拟进程id
>
> **例如：** jmap -dump:format=b,file=Eclipse.bin 6244

# 看到了 4.2.5 小节



