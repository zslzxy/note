[TOC]
# java面试基础题型
### 1、java的八种基本数据类型
基本数据类型：byte、int、double、float、boolean、char、long、short
基本数据类型的封装类型：Byte、Integer、Double、Float、Boolean、Character、Long、Short

### 2、什么是程序？
程序指的是为完成某一项功能或者解决某一个问题而写的一系列有序的指令的集合。

### 3、什么是SDK，什么是JDK？
SDK的全称：Software Develepment Kit --- 软件开发工具包。专门为开发人员提供的对应的开发语言与工具包。  

JDK的全称：Java Develepment Kit --- 专门为java程序员提供的一套开发语言的工具包。

### 4、String的理解？
String底层是由char数组封装起来的，不是java的基本数据类型，实际是被final进行修饰的，不能够被继承，String指向的是对象。

### 5、& 与 && 的区别？
共同点：  
两者都是可以表示为逻辑与(and),当运算符两边的表达式都为true的时候，结果才为true；如果一方为false，则返回false。

不同点：  
&& 就有短路功能，当前面的表达式为false的时候，就不会继续执行后面的表达式。
& 可以作为位运算符，进行位的运算。

### 6、java转义字符？
![image](https://note.youdao.com/yws/api/personal/file/E37B4147582F4B11BC98BE9246DC7B40?method=download&shareKey=e8072c70f12bf4f2bec141a2bdc6ccfe)


### 7、char类型存储中文汉字？
在Unicode的UTF-8编码中，所有的汉字占三个字节。

### 8、== 与 equals() 方法的区别？
1）== 用于比较两个变量的值是否相等，比较基本数据类型或者引用数据类型是否相等，只能用 == 来进行比较。

2）equals()方法 主要适用于两个对象之间的比较。

3）总结：  

```
String a=new String("foo");
String b=new String("foo");

当使用 == 比较a、b的时候，是比较的地址，而a与b的地址不同，所以为false。
当使用 equals 比较的时候，是比较的内容，a与b的内容相同，所以为true。
```


### 9、静态变量与实例变量的区别？
语法的区别：  
静态变量必须在前面使用static关键字来修饰，实例变量不需要。  

语义的区别：  
- 静态变量是当类的字节码文件被加载以后，会直接在静态区分配一部分内存来存放这个静态变量，能够不实例化而直接调用它。  
- 实例变量必须创建类的实例对象，才能进行调用。

### 11、static关键字的调用？
static方法的调用可以直接使用 类名+方法名 的方式进行调用。   
static方法不能够在内部调用非static方法。

### 12、Integer与int的区别？
Integer是int基本数据类型的封装类，Integer的默认值为null，用于区分一个属性是否为未赋值或者值为0的话，必须使用Integer包装类型。Integer提供了将数字字符串转换为数字的方法。Integer定义了证书的最大值与最小值。

### 13、Overload与Override的区别？
OverLoad：  
指的是方法的重载，重载指的是方法名相同，方法参数不相同，Overload的方法的返回值没有限制。

Override：  
指的是方法的重写，子类对父类进行继承，重写父类的方法，相当于是覆盖掉父类的方法。但是：方法的返回值不能够修改，方法抛出的异常必须要比父类抛出的异常少。

### 14、线程如何同步通信？
使用synchronized关键字来同步方法或者同步代码块的方式进行线程同步通信的操作。  
注意：多个同步代码块必须是同一个监视器对象才能够实现互斥效果，而同步方法的监视器对象就是this关键字。

### 15、Servlet的生命周期
1）请求发送到服务器，服务器会产生新的线程，来调用servlet的 init() 方法。

2）服务器接收到servlet请求后，会产生新的线程来调用 service() 方法，在适当的时候转到doXXX() 方法。

3）执行doXXX()方法。

4）servlet生命周期结束以后，调用destroy()方法，执行销毁程序。

##### servlet的生命周期图：
![image](https://note.youdao.com/yws/api/personal/file/4A83F6584E514526AE887A75DBB1773E?method=download&shareKey=eec7206c749509e59c77305e9a38e5a9)

### 16、分层设计的优势：
简介：  
分层设计就是将各个功能与流程进行模块化的划分，实现web、service、dao各层的模块化结构。好比现在的MVC模型。

优势：  
a）便于软件之间的解耦。  
b）便于分工合作。  
c）便于软件的维护与管理。  
d）便于模块的重复使用。  
e）便于更换产品或者框架，不至于动一小部分而影响大局。  
f）更加有利于产品的扩展。  

### 17、序列化接口的id：
简介：  
当实现序列化接口的时候，默认会自动为这个类生成一个随机id，或者自己手动指定序列化的id。

作用：  
序列化的id是反序列化的一个重要组成部分。反序列化是需要将两个序列化的id来进行对比，对比成功才能够进行反序列化，不然会导致反序列化失败。


### 18、JDK、JRE、JVM三者之间的区别：
三者间的区别：https://www.cnblogs.com/zbl3033/p/3245944.html

##### 1）JDK：java developmentkit
java开发工具包，针对开发者，主要包含了jre，jvm，jdk源码包，以及bin文件夹下的用于开发、编译、运行的一些指令器。  
特点：主要包含了大量的java API应用程序接口。jdk包含jre。
##### 2）JRE：java runtime environment
java运行时环境。主要包含了jvm与运行时基本类库(rt.jar)。  
特点：  
主要包含了JVM与java核心类库和支持文件。它不包含开发工具——编译器(javac.exe)、调试器、jar.exe和其它工具。所有的java程序必须在jre环境上运行。jre包含jvm。
##### 3）JVM：java虚拟机
是一个可以识别.class文件的小型系统。让class文件和用户真是的操作系统隔离，屏蔽了操作系统的差异性。因此形成了java的一大特点：一次编译，处处运行。  
特点：JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。JVM 的主要工作是解释自己的指令集（即字节码）并映射到本地的 CPU 的指令集或 OS 的系统调用。

### 19、什么是SOA？
SOA(面向服务架构)是一个组件模型，它将应用程序的不同功能单元通过这些服务提供的接口联系起来，主要适用于Internet环境下的业务集成。

SOA是一种软件系统架构，好比是一种模型。它通过需求来进行应用组件的分布式部署、组合与使用，降低系统耦合度，它能够更迅速、可靠的架构整个业务系统，从容面对业务的变化与迭代。


### 20、Spring的IOC、DI、AOP概念
IOC(Invert Of Control)容器：控制反转。其思想是反转资源获取的方向。**主要意味着的是将你设计好了的对象交给容器来进行空值，而不是传统的在你的对象的内部直接控制。**

- 传统的java程序设计，我们直接在对象内部通过new来进行创建对象，是程序主动的去创建对象。
- 而IOC是专门一个容器来创建对象，即是由IOC容器来控制对象的创建。
- 传统的程序是由我们自己在对象中主动控制去直接获取依赖对象，这就是正转。
- IOC容器创建对象，然后容器帮我们查找并依赖注入依赖对象，对象知识被动的接受依赖对象。这就是反转。

AOP(Aspect Oriented Program)：面向切面编程。将功能模块(日志记录，性能统计，安全控制，事务处理，异常处理等)对应的对象作为切面嵌入到各个系统模块中，代用的是代理技术，将切面功能的代码加入到系统模块中。AOP需要的是切面与切入点。

DI：依赖注入。将以前new的方式更换为---IOC容器启动，将标注有加入IOC容器的各个组件自动装配到IOC容器中，当需要某一个组件的时候，直接从IOC容器中通过DI(依赖注入)的方式提供给组件。


### 21、面向对象
面向对象是强调的是人类日常生活的逻辑思维的方法与模式。将一切事物都看作是对象，将对象作为主体来构建系统而不是将功能过程作为主体来构建系统。

对象是属性及其操作的封装体；对象可按其性质划分为类，对象成为类的实例；实例关系和继承关系是对象之间的静态关系；消息传递是对象之间动态联系的唯一形式，也是计算的唯一形式；方法是消息的序列。

### 22、面向对象的特征：
##### 封装：
封装是保证软件各个部件具有良好的模块化的基础。封装能够实现产品部件之间的“高内聚，低耦合”的理念，能够防止程序之间的相互依赖产生冲突。封装一般是将属性与方法封装到一个“模块”中，也即是一个类里面。通常情况下，一般将属性定义为私有的，将方法定义为public的，实现程序的封装。
##### 继承：
在定义一个类的时候，在已有的一个类的基础之上，将一已有的类的内容作为自己的内容，并可以添加功能或者修改部分功能，这就是继承。继承的子类拥有父类的所有属性与方法，提高了软件的可重用性与可扩展性。
##### 多态：
一个事物，具有多种的表现形态。比如方法的重载，重写，子类对象的多引用等。

多态的技术：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。  
实现多态的必要条件：继承，重写 ，父类引用指向子类对象。

### 22、abstract 与 interface 的区别
abstract 抽象的意思。抽象方法必须要定义在抽象类里面。子类必须实现抽象父类的所有方法。

interface 接口。接口是abstract的一种特殊方式，接口中的方法默认是使用public abstract修饰。

区别：
- 抽象类可以有构造器，可以有已经实现了的方法，不能被实例化。  
- 接口只能有倡廉与方法头。常量默认为public static final 修饰，方法默认为public abstract修饰。


### 23、length属性与length()方法
数组具有 length属性，数组不具备 length()  方法。

String具有 length() 方法，不具备 length() 属性。

### 24、try{}里面直接return返回，finally{}中的内容在什么时候执行？
当try{}里面有return返回，finally里面的代码必须要执行，而且是在返回中进行执行。相当于你返回你的，我执行我的。

### 25、final、finally、finalize的区别？
final ：final 用于声明属性、方法与类的，表示属性不可变，方法不可覆盖，类不可继承。

finally ： 异常处理的结构的一部分，用于指定必须执行的代码。

finalize ： 垃圾收集器执行的时候会调用被回收对象的方法。

### 26、Socket(套接字)编程
socket具有面向连接与面向无连接的两种操作方式。

socket面向无连接的操作是使用数据报协议，特点是高效、不安全。

socket面向连接的操作是使用TCP协议，socket必须在数据包发送之前与目的地的socket取得连接。socket通过描述IP地址与端口来实现与serverSocket(服务端)的对等连接，连接成功以后，打开会话---读写---关闭会话。

### 27、线程等待的sleep()与wait()方法
sleep()方法是在Thread类中，表示的是让线程暂时休眠，会自动唤醒。不释放对象锁。

wait()方法也是Thread类的方法，表示让线程暂停执行释放CPU与对象锁(同步锁)，让其他线程先执行。重新执行需要使用notify()或者notifyAll()方法唤醒以后才行。

### 28、同步与异步的区别
##### 同步：
发送一个请求，等待返回，然后才能继续发送请求。当两个人同时操作同一个数据的时候，一个人可能是修改的另一个人已经修改了的数据，这样容易产生脏数据，所以数据必须有同步存取的限制。同步能限制避免脏数据的产生与死锁的现象。

##### 异步：
发送一个请求，在这个请求还没有返回的时候，可以执行下一个请求的发送。异步处理能够极大地提高效率，支持并发执行。

### 29、Lock与synchronized的异同
Lock锁：Lock锁是由程序员定义，程序员解锁，且必须要在finally中解锁。

synchronized：阻塞。synchronized是给代码添加一道锁，当线程执行完毕以后，自动释放锁，允许下一个线程的进入。

### 30、GC垃圾回收机制
GC：垃圾回收，使用GC可以进行来及空间的释放操作。

垃圾回收方式：垃圾回收器通常作为一个单独的低级别的线程运行，在不可知的情况下对已经死亡或者长时间未使用的对象进行清除与回收。

垃圾回收优点：垃圾回收机制能够有效的防止内存的泄露，清理垃圾，合理利用资源。

垃圾回收器的原理：GC采用的是有向图的方式来记录与管理堆中的所有对象。通过有向图来查看哪一些是 “可达的”，哪一些是 ”不可达“ 的，当GC发现 ”不可达“ 的时候，GC就负责回收这些内存空间。

### 31、内存泄漏与内存溢出
内存泄漏：是指一个不再被程序使用的对象或者变量一直占据着内存，导致内存的泄露。

解决办法：java语言的垃圾回收机制GC能够完成对内存泄漏的清理。

内存溢出：申请的内存超出了JVM能提供的内存大小，此时称之为溢出。

解决办法：扩大JVM的内存空间。

### 32、Cookie与session的区别
Session是存放在服务器端的。当客户端第一次发送请求到服务端的时候，服务器会自动生成一个Session和一个Session ID来唯一标识这个Session，并将其发送给客户端。当浏览器第二次发送请求时，服务器会对比请求中的session ID来进行比较，从而找到用户对应的session。

Cooike是存放在客户端的。服务端通过设置cooike的方式来将session ID发送到浏览器（也就是说将session转换为cooike返给了浏览器并保存在浏览器）。如果不设置cooike过期时间，则会导致浏览器关闭，cooike也就随着失效。当设置了cooike过期时间，则在规定的时间内，即是关闭了浏览器，cooike也会继续存在，直到cooike过期。

### 33、Forward与redirect的区别
##### forward：  
仅仅是容器中的控制权的专项，客户浏览器地址中不会显示出转向后的地址；

优点：更加高效，能够隐藏实际的链接。  
具体实现：forward是向服务器请求资源，服务器根据URL进行寻找并返回发送给浏览器，而浏览器的地址栏没有地址的变化。

##### redirect：  
完全的跳转，浏览器的地址也会跟着跳转，并重新发送链接。

具体实现：redirect是服务端根据逻辑，发送一个状态码，告诉浏览器重新去请求那个地址，浏览器一般会使用请求的所有参数进行请求，所以session与request都能够得到。


### 34、request.getAttribute()与request.getParameters()方法的区别
request.getAttribute()：可以在下一个页面获取到基本数据类型或者对象类型的数据。

request.getParameters()：只能在下一个页面获取到String类型的数据。


### 35、过滤器(Filter)
##### 简介：
Filter是servlet中非常实用的技术，通过Filter技术对web服务端进行资源的管理，对文件、请求进行拦截，从而实现一些特殊的功能。

##### 用法：
编写自己的Filter，实现Filter接口中的doFilter()方法，配置上对什么服务、资源进行拦截以后，每次访问这个资源，在执行servlet内置的service()方法之前都会先调用doFilter()方法。

##### 生命周期：
init() --- Filter的初始化，在启动web服务器的时候执行这个方法，只创建一次。

doFilter() --- Filter需要执行的代码，当过滤器被触发，就会在执行service()方法之前执行doFilter()方法。

destory() --- 过滤器的销毁，在web服务器停止的时候销毁。


### 36、MVC设计模式
##### 简介：
MVC(Model View Controller)：模型-视图-控制器。是一种典型的软件设计方法。用将业务逻辑、视图等进行分离到各个部件，从而达到分层解耦的效果。

Model业务逻辑与View视图进行分离，而Controller控制器则是确保M与V二者间的同步。答 通过这种设计模型把应用逻辑，处理过程和显示逻辑分成不同的组件实现。这些组件可以进行交互和重用。

### 37、数据库连接池
##### 简介：
数据库连接池是创建和管理多个连接的一种技术，创建的连接可以被需要用到它的所有线程使用。当某个线程需要使用连接的时候，连接池会将已有的连接“借用”给线程使用，带到县城使用完毕，就会“退回”给数据库连接池。连接池创建的连接收到配置参数的限制。

##### 优点：
缩短创建数据库连接的时间。简化了编程模型。

### 38、assert(断言)在Java中的作用
##### 简介：
assert在软件开发中是一种常见的调试方式，很多开发语言都支持这种机制。断言用于保证程序最基本、关键的正确性。断言检查通常在开发与测试阶段开启。

##### 实现方式：
短延时一个包含布尔表达式的语句，再执行这个语句时，如果返回值为false，则系统报错assertionError。

### 39、XML的理解
XML主要的作用：信息配置、数据交换

XML数据交换：XML将数据用标签组装其阿里，然后打包加密后，通过网络传输到接收方，接收方通过解密解压以后还原数据。但是现在已经几乎被JSON取代。

XML配置信息：使用XML文件来记载配置信息。

### 40、事务的ACID
- 原子性(Atomic)：事务是一个不可分割的整体，一组事务要么不发生，要么全部发生。

- 一致性(Consistency)：事务开始前、结束后系统状态是一致的。
- 隔离性(Isolated)：事务不收其他并发执行的事务的影响。
- 持久性(Durable)：事务娃安成后所作的改动都会被持久化，即使发生灾难性的失态，也可以通过日志与备份的数据来重建数据。

### 41、事务的补充
只有存在并发数据访问的时候才需要事务的控制。不然会导致数据读取问题：  
- 脏读：A事务读取B事务尚未提交的数据并在此基础上操作，而当事务B执行回滚，那么A读取到的数据就是脏数据。

- 不可重复读：事务A重新读取前面读取过的数据，返现数据已经被一个已经提交的事物B修改过了。
- 幻读：指的是两次查询，查询的结果不一致，第二次插入了事务B提交的行。

### 42、JDBC进行事务的处理
Connection提供了事务处理的方法。通过调用 setAutoCommit(false) 来设置手动提交事务。事务完成以后使用commit()方法显示提交事务；如果事务处理过程出现异常，还需要通过rollback()方法来进行事务的回滚。

### 43、正则表达式的作用
正则表达式用于处理字符串的。在制定某一些复杂规则的字符串的时候，使用正则表达式来描述与限制规则。

java提供的正则表达式方法：matchs()   replaceAll()   replcaeFirst()   split() 方法。
   使用 Pattern 类来表示正则表达式对象。


###    44、实现会话跟踪技术
##### 会话跟踪：
HTTP协议本身是无状态的，服务器为了区分不同的用户，需要对用户会话进行跟踪，相当于是进行用户登记，为用户分配唯一id。
##### 实现方式：
①URL重写：在URL中添加用户会话的信息作为请求的参数，或者将唯一的会话id添加到URL结尾用于标识一个会话。

②设置表单隐藏域：表单隐藏域添加字段，在浏览器不显示，但是会将隐藏的字段提交到服务器。

③cookie：设置cookie来实现对会话的跟踪。

④HttpSession：用户访问网站，会自动创建一个httpsession，来实现用户的会话的跟踪，功能最强大。

### 45、持续集成与持续部署
##### 1、持续部署
在项目开发过程中，不仅仅需要单元测试，更需要部署到服务器上进行测试。避免项目在前期单元测试没问题，集成在一起测试出现异常。  
持续部署的关注点在于项目功能部署服务器以后，能够正常运行，为下一步测试环节和最终用户的使用做准备。
##### 2、持续集成	
经常的，频繁的把所有的模块集成在一起测试，尽早发现问题。  
持续集成的关注点在于尽早发现问题，及时修复。
##### 3、持续交付
用小版本不断的uaisu迭代，不断收集用户反馈信息。用最快的速度改进，优化。  
持续交付的关注点在于研发团队的关键代码能够尽快让用户体验到。 
##### 4、总体目标
1）降低风险，经常集成，测试，有利于查漏补缺，更早发现问题，及时解决，保证软件的健康状况。  
2）减少重复过程。持续集成工具能够把构建环节从手动完成转换为自动完成，还可以通过多次继承，尽早的发现问题。  
3）任何时间、任何地点生成可部署的软件 。  
4）增强项目的可见性  
5）建立团队对开发产品的信心   

### 46、程序流程控制：
顺序结构： 从上往下的逐步执行，中间没有任何判断与跳转。

分支结构： 根据条件选择性的执行代码。比如 if....else ...和 switch....case...‘

循环结构： 根据循环条件，重复的执行某一段代码，比如： while，  do...while，  for， 佛reach循环。


### 47、java中Object的方法有哪些？
getClass()---得到一个类Class。

hashCode()---用于得到hashCode值，然后根据hashCode值进行存储等操作。

equals()---用于比较两个对象是否相等。

clone()---将一个对象进行复制的操作，默认是进行浅拷贝的，如果需要进行深拷贝。  
实现步骤：  
第一步：在需要被克隆的类中，实现一个接口 Cloneable  
第二步：在需要被克隆的类中，重写 clone() 方法。


toString()---将一个对象变成字符串来进行返回。

notify() / notifyAll() / wait() ---线程通信与等待。

finalized() ---垃圾线程执行需要调用的方法。


### 48、java中System类包含的方法？

##### 1）System对PrintStream(打印流)/InputStream(输入流)的支持：
流 | System的成员变量 | 介绍
---|---|---
static PrintStream | err | 标准错误输出流
static PrintStream | out | 标准输出流
static InputStream | in  | 标准输入流

##### 2）常见方法：
- public static void exit(int status)  系统退出 ，如果status为0就表示退出。  
代码为：

```
System.exit(0);
```

- public static void gc()   运行垃圾收集机制，调用的是Runtime类中的gc方法。
- public static long currentTimeMillis()  返回以毫秒为单位的当前时间。
- public static void arraycopy(Object src,int srcPos, Object dest,int desPos,int length) 数组拷贝操
    - 第一个参数：原数组
    - 第二个参数：原数组的起始位置
    - 第三个参数：目标数组
    - 第四个参数：目标数组的起始位置
    - 第五个参数；需要复制数组的长度  
代码为：

```
    public static void main(String[] args) {
		int num1[] = {1,4,67,96,34};
		int num2[] = new int[num1.length];
		
		System.arraycopy(num1, 0, num2, 0, num1.length);
		System.out.println(num2);
		for(int i = 0 ;i < num1.length;i++) {
			System.out.println(num2[i]);
		}
	}
```

- public static Properties getProperties() 取得当前系统的全部属性。
- public static String  getProperty(String key) 根据键值取得属性的具体内容。  
代码为：

```
System.getProperty("java.version"); //得到java的版本
System.getProperty("java.home");  //得到java的安装目录
```


### 49、什么是select模型poll模型，什么是epoll模型？
这三者都是IO多路复用模型。  
select模型：在IO多路复用上，有着数量的条件限制，一般只能监视1024个链接，在高并发情况下不适用。是线程不安全的。

poll模型：虽然取代了select的监事条件的限制，但是仍然是线程不安全的。

epoll模型：能够保证线程安全的情况下进行IO多路复用操作。

### 50、Runtime类的方法

```
Runtime rt = Runtime.getRuntime();
		
System.out.println("处理器数量"+rt.availableProcessors()+"个");
System.out.println("JVM总内存数"+rt.totalMemory() + " byte");
System.out.println("JVM的空闲内存数"+rt.freeMemory() + " byte");
System.out.println("JVM的可用过最大内存数"+rt.maxMemory() + " byte");
rt.gc();
```

### 51、Comparable与Comparator

#### 1）Comparable接口，用于比较排序的操作
自定义的类能够实现Comparable接口，重写ComparaTo()方法，来实现自定义排序。

代码为：

```
public class Person implements Comparable<Person> {

	private String name;
	private int  age;

	/**
	 * 此方法是用来实现重写排序的方法
	 */
	@Override
	public int compareTo(Person o) {
		return this.age-o.age;
	}
}
```

#### 2）Comparator接口，用于排序的操作
创建一个类，专门作为一个类的排序的实现规则。  

代码为：
```
/**
 * 为Person2对象创建一个排序的比较器
 * @author 10838
 *
 */
public class Person2Comparator implements Comparator<Person2> {

	@Override
	public int compare(Person2 o1, Person2 o2) {
		// TODO Auto-generated method stub
		return o1.getAge()-o2.getAge();
	}

}
```
调用方式为：使用 Arrays.sort() 排序的时候，使用自定义的比较器
```
Arrays.sort(person2s,new Person2Comparator());
```

### 52、Tomcat优化
#### 1）JVM参数优化：
- -Xms ：表示程序启动的时候占用的内存的大小。

- -Xmx ： 表示程序运行期间最大的可用内存大小。
- -Xss ： 设定每个线程的堆栈大小。

使用方式: 在cataltina.bat中，设置JAVA_OPTS的属性，例如：
```
JAVA_OPTS='-Xms256m -Xmx512m'
```

#### 2）禁用DNS查询
客户端与服务器之间的请求，都会先去连接到NDS服务器，再进行转换为IP地址。这个过程耗费时间与网络，可以禁用这个属性。

禁用DNS查询方式：修改server.xml文件的 enableLookups 参数值：

```
<Connector ...... enableLookups="false" ...... /> 
```

#### 3）更改tomcat的BIO为NIO模式
tomcat默认是使用BIO模型，而一般在高并发的情况下，是使用NIO来进行IO操作的。

修改方式：将server.xml文件中的 protocol 修改为 org.apache.coyote.http11.Http11NioProtocol，重启即可生效。
```
<Connector port=”8080″

protocol=”org.apache.coyote.http11.Http11NioProtocol”

......
......

URIEncoding=”UTF-8″ />
```

#### 4）tomcat其他优化
- maxSpareThreads : 如果空闲状态的线程数多于设置的数目，则将这些线程中止，减少这个池中的线程总数。

- minSpareThreads : 最小备用线程数，tomcat启动时的初始化的线程数。

- URIEncoding=”UTF-8″ :使得tomcat可以解析含有中文名的文件的url。

- connectionTimeout : connectionTimeout为网络连接超时时间毫秒数。

- maxThreads : maxThreads Tomcat使用线程来处理接收的每个请求。这个值表示Tomcat可创建的最大的线程数，即最大并发数。

- useURIValidationHack设成”false”，可以减少它对一些url的不必要的检查从而减省开销。

- compression=”on” 打开压缩功能，它的原理是，在客户端请求网页后，从服务器端将网页文件压缩，再下载到客户端，由客户端的浏览器负责解压缩并浏览，节省流量传输，提升效率。
    - compressionMinSize=”2048″ 启用压缩的输出内容大小，这里面默认为2KB
    - noCompressionUserAgents=”gozilla, traviata” 对于以下的浏览器，不启用压缩
    - compressableMimeType=”text/html,text/xml”　压缩类型
    

### 53、什么是p2p，o2o？
#### 1）o2o简介：
o2o英文为 Online To Offline。将线上的商务机会与互联网结合，让其成为线下交易的前台。

#### 2）p2p简介：
p2p英文为Peer To Peer。即个人对个人的意思。其定型的模式为：网络信贷公司平台。

### 54、==与equals()的区别？
- 基本数据类型：  
    - 在基本数据类型的情况下，是使用 == 来对基本数据类型进行判断其是否相等。
    - 基本数据类型使用 == 是对栈中的值进行比较。
- 引用数据类型：
    - 在引用数据类型中，使用 == 来进行判断的时候，是比较栈中存放的地址是否相等。
    - 在饮用数据类型中，使用 equals() 来进行比较，如果未重写的话，也是比较两个是否是同一个对象；如果重写了的话，调用自定义的equals()方法来进行比较。


### 55、软件开发流程
- 1）需求分析：  
首先先与客户进行沟通，了解客户的需求与情况，使用工具软件进行软件模块的划分。  
再使用文档构建一个总体的需求文档，并描述软件的大概功能以及模块的划分。

- 2）概要设计：  
在了解客户的需求以后，进行软件的概要设计。需要对软件进行 基本的流程处理、组织结构划分、模块划分、功能设计、接口设计等操作。

- 3）详细设计：  
对软件进行详细的设计，包括了软件的使用算法、数据结构、使用语言、程序的结构层次、程序的测试环境等。

- 4）编写代码：  
在详细设计完成以后，会进行程序的编码阶段，使用代码将程序的功能、模块进行编写完成。

- 5）项目测试：  
程序的测试是测试程序的每一个功能以及组合在一起是否能够正常运行。测试可以分为内部测试、外部测试、黑盒测试、白盒测试等。

- 6）软件交互：  
当软件测试达到预定要求以后，需要进行项目的详细文档的编写、使用手册以及数据字典等。然后将整体进行打包提交，进行项目的交付。


### 56、什么是面向服务架构（SOA）？
面向服务架构，是一个组件模型，它将应用的不同的服务单元通过这些服务之间定义的良好的接口和契约联系起来。接口是采用中立的方式进行定义的，它是独立于硬件系统、操作系统与编程语言。能够让程序使用一种统一的简单的方式进行服务之间的调用。

面向服务架构能够实现程序耦合度的降低。服务之间通过网络来进行简单、精确的接口进行通讯，不涉及底层的代码的实现与通讯模型。

### 57、java正确使用Integer.valueOf()
java中可以 使用 Integer.valueOf("123") 来将字符串转化为数字，但是想继续强转成String类型的话，会报错。

### 58、js中的三种弹出窗口
**第一种：只有一个确定按钮---警告框**  

```javascript
alert(“确认窗口”);
```

**第二种：弹出一个有确定与取消的按钮---确认框**  

```javascript
res = confirm("弹出确定与取消两个按钮的对话框");
if(res == true){
    console.log(点击了确定"");
} else {
    console.log("点击了取消");
}
```

**第三种：弹出一种有输入框的对话框---提示框**  
```javascript
res = prompt("请输入姓名：");
console.log(res);
```

### 59、Integer在什么时候才会创建一个新对象？
有如下代码：
```
Integer f1 = 100, f2 = 100, f3 = 150, f4 = 150;
System.out.println(f1 == f2);
System.out.println(f3 == f4);
//结果为 true、false
```
解释：在-128~127之间的数据，当创建两个相同的值的对象，就是上面的f1与f2，就不会创建一个新的对象。在超出了这个范伟以后，创建两个相同的对象，那么就会创建不同的两个对象。

### 60、forward与redirect的区别？
- forward是服务器去请求资源，服务器直接访问目标地址的URL，而地址栏（也就是浏览器）的地址不会发生改变。
- redirect是服务器根据逻辑发送一个状态码给浏览器，告诉浏览器重新去请求那个URL地址，地址栏会发生改变。

### 61、如何将GB2312编码的字体改为IOS-8859-1编码？
```
String str1 = "adf";
String str2 = new String(str1.getBytes(GB2312),"ISO-8859-1");
```

### 62、什么是Servlet？
答：Servlet 是用来处理客户端请求并产生动态网页内容的 Java 类。Servlet 主要是用来处理或者是存储 HTML 表单提交的数据，产生动态内容，在无状态的 HTTP 协议下管理状态信息。

### 63、java中final与abstract能够一起使用吗？
- 在Java中，final表示的是最终的意思，不能够被修改、不能够被重写。
- 在Java中，abstract表示抽象的意思，抽象方法必须要被重写、实现。
- 所以，java中的final与abstract关键字不能够在一起使用。