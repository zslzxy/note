# Java编码规范

[易极付编码规范地址](http://192.168.45.88/peigen/tech-manage-doc/blob/master/%E4%BA%BA%E5%91%98%E7%AE%A1%E7%90%86/%E5%88%B6%E5%BA%A6%E8%A7%84%E8%8C%83/%E6%8A%80%E6%9C%AF%E4%B8%AD%E5%BF%83/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/%E6%98%93%E6%9E%81%E4%BB%98%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83.md?tdsourcetag=s_pctim_aiomsg)

[TOC]

## 一、代码规范

3、除了**行结束符序列**，ASCII水平空格字符(0x20，即空格)是源文件中唯一允许出现的空白字符 )

4、**制表符不用于缩进，只能使用空格。**

5、对于具有特殊[转义序列](http://zh.wikipedia.org/wiki/%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97)的任何字符(\b, \t, \n, \f, \r, \", \'及\)，我们使用它的转义序列 。

6、对于剩余的非ASCII字符，是使用实际的Unicode字符(比如∞)，还是使用等价的Unicode转义符(比如\u221e)，取决于哪个能让代码更易于阅读和理解（注意给出注释）。 



7、一个源文件包含(按顺序地)，每个部分之间用一个空行隔开：

- 许可证或版权信息(如有需要)。如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。 

- package语句。即package语句写在一行里 。

- import语句

  - import不要使用通配符。

  - 每个import语句独立成行 。

  - import语句可分为以下几组，按照这个顺序，每组由一个空行分隔(组内不空行，按字典序排列。)：

    ```
    1. 所有的静态导入独立成组
    2. com.google imports(仅当这个源文件是在com.google包下)
    3. 第三方的包。每个顶级包为一组，字典序。例如：android, com, junit, org, sun
    4. java imports
    5. javax imports
    ```

- 一个顶级类(**只有一个**)。

  - 每个顶级类都在一个与它同名的源文件中 。
  - 当一个类有多个构造函数，或是多个同名方法，这些函数/方法应该按顺序出现在一起，中间不要放进其它函数/方法。 



8、大括号换行规则：

```
左大括号前不换行
左大括号后换行
右大括号前换行
如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。例如，如果右大括号后面是else或逗号，则不换行。
一个空的块状结构里什么也不包含，大括号可以简洁地写成{}，不需要换行。例外：如果它是一个多块语句的一部分(if/else 或 try/catch/finally) ，即使大括号内没内容，右大括号也要换行。
```



9、换行规则：

- 自动换行时候，至少四个空格（只能使用空格，不能使用制表符）。
- 如果在`非赋值运算符`处断开，那么在该符号前断开(比如+，它将位于下一行) 。
- 如果在`赋值运算符`处断开，通常的做法是在该符号后断开(比如=，它与前面的内容留在同一行)。 

10、以下情况下，需要有一个空行：

- 类内连续的成员之间：字段，构造函数，方法，嵌套类，静态初始化块，实例初始化块。 
- 在函数体内，语句的逻辑分组间使用空行。



11、枚举类的常量间用逗号隔开，换行可选。



12、声明变量：

- 一次只能声明一个变量，不要组合声明（例如：int a,b;  是错误的）。

- 需要变量的时候才声明，并尽快初始化。

- 数组的初始化可以写成块状结构，例如：

  ```
  new int[] {
      0, 1, 2, 3 
  }
  
  new int[] {
      0,
      1,
      2,
      3
  }
  
  new int[] {
      0, 1,
      2, 3
  }
  
  new int[]{0, 1, 2, 3}
  ```


13、switch与代码块的缩进：**缩进为两个空格。**

14、switch规定：

​	在一个switch块内，每个语句组要么通过`break, continue, return`或抛出异常来终止，要么通过一条注释来说明程序将继续执行到下一个语句组， 任何能表达这个意思的注释都是OK的(典型的是用`// fall through`)。这个特殊的注释并不需要在最后一个语句组(一般是`default`)中出现。 每个switch都应该包含default，即使default里面不含有任何代码。例如：

```
switch (input) {
    case 1:
    case 2:
        prepareOneOrTwo();
        // fall through
    case 3:
        handleOneTwoOrThree();
        break;
    default:
        handleLargeNumber(input);
}
```



15、名称约定：

- 包名全部小写。

- 类名以驼峰命名法规则来进行命名，首字母大写。例如：UpperCamelCase 
- 测试类命名以它要测试的类的名称开始，以Test结束。例如：UpperCamelCaseTest
- 方法名以驼峰命名法规则来命名，首字母小写。例如：lowerCamelCase 
- 常量名命名规则：全部字母大写，用下划线分隔单词 。例如：CONSTANT_CASE 
- 非常量字段名、参数名、局部变量名使用驼峰命名法，首字母小写。例如：lowerCamelCase 
- 类型变量名，通常是使用两种方式：
  -  单个字母大写 + 数字
  -  类名的规则 + T



16、注释形式：

```
// XXXXX

/* 
* 
*/
```

17、Javadoc一般形式：

```
/**
* Multiple lines of Javadoc text are written here,
* wrapped normally...
*/
public int method(String p1) { ... }
```

​	标准的Javadoc标记按以下顺序出现：`@param`, `@return`, `@throws`, `@deprecated`, 前面这4种标记如果出现，描述都不能为空。 当描述无法在一行中容纳，连续行需要至少再缩进4个空格。 



18、接口方法注释如下：

```
/**
 * 删除用户收藏的一个商品。
 * 逻辑删除：delete_flag置为1
 *
 * @param memberId  会员ID 
 * @param itemSku   商品序列号
 *
 * @return 是否删除成功：1.成功，0.失败
 * @throws ServiceCustomException
 */
```

19、类注释与版权注释：使用 file template 自动生成。

20、方法体类的注释：

```
// 1. 尝试更新已有的收藏
int updateForCreate = dao.doUpdate(memberId, itemSku);
// 2. 更新成功，返回新增成功
if (updateForCreate > 0) {
return updateForCreate;
}
// 3. 没有更新成功则需要添加用户收藏信息
```

21、禁止行尾添加注释。



22、异常处理：

- 捕捉的异常，不能够不做任何的处理就截断，至少要记录日志 或 者重新抛出。
- 最外层的业务使用者，必须要对异常进行处理，转换为用户可以理解的内容。

23、资源的使用：

- 对系统资源的访问，使用以后必须释放系统资源。例如：文件流、线程、网络连接等。
- 对于文件、流的操作，必须使用finally进行关闭。
- 对于线程，必须通过线程池提供，不允许自行创建。
- 数据库连接，只能够使用框架中的数据库连接池，不允许自行创建连接。

24、本地事务操作

- 业务逻辑上不能够并发访问的数据，必须财通事务和上锁的方式进行处理。
- 对于业务逻辑上要求数据完整性的数据（同事操作多张表，或者重复操作多张表），必须进行事务的处理。

25、线程安全处理：

- 多线程必须要注意发生死锁等操作。
- 线程上下文变量的设置清除必须配对。
- 静态的或者单例的对象，必须是线程安全的。
- DateFormat是非线程安全的，类变量使用的时候会破坏。所以每次都必须要重新构造对象，，或者使用DateUtil工具类。
- 为记录加锁时，必须要保持一致的加锁顺序，避免死锁。

25、用户信息安全：

- 不能将敏感信息，例如 卡号、密码等信息输出到日志中。

- 学会使用以下注解：

  ```
  @ToString.Maskable 调用ToString#tostring时输出掩码
  @ToString.Invisible 调用ToString#tostring时不输出
  @JSONField(serialize = false) json序列化时不输出，要考虑是否有反序列的情况
  ```



26、访问权限规范：

- 禁止把测试页面公布到公网。
- 禁止把http定时任务url暴露到公网。
- 禁止测试环境直接访问线上。
- 禁止把生产环境导入到本地。
- 禁止将管理、统计功能直接暴露到公网中（如druid管理页面、swagger管理页面）。



27、数据库开发规范：

- 尽量避免在数据库做运算操作。

- 单表避免超过1000w行。

- 单表的列上线控制在20-50区间内。字段少能够提高并发效率。

- 平衡范式与冗余：适当牺牲范式，效率优先，性能提升。

- 拒绝大SQL、拒绝大事务、拒绝大批量。


28、数据库命名规范：

​	在MySQL数据库中，表名、字段名、触发器、存储过程以及函数的命名，统一采用**26个英文字母（区分大小写）和0－9这十个自然数，加上下划线*组成**，共63个字符.不能出现其他字符（注释除外）,也不能以数字或‘*’ 开头，非必须情况下，不使用自然数. 

- 对于MySQL数据库， 表名、字段名统一采用小写字母;  
- Oracle数据库中表名、字段名统一采用大写字母；
- 若名称过长可采用单词缩写.。
- 表名： 根据表所描述的业务实体，采用英文单词加`_`的形式命名.若表名太长，英文单词可采用缩写.如：`user_info`. 
- 视图名（视图能不用就不用）：视图名加`_view”后缀`。 如：`user_withdraw_view`. 
- 触发器名：触发器功能描述名加“`_tr`”后缀。 如:`insert_balance_hist_tr`. 
- 存储过程：存储过程功能描述名加“`_sp`”后缀。如：`load_user_trade_sp`. 
- 函数名：函数功能描述加“`_fn`”后缀。 如：`generate_password_fn`. 
- 主键名：主键字段或主键描述加“`_pk`” 如：`user_id_pk` 
- 外键名：外键字段 加“*fk” 如：`user*id_fk` 
- 索引：索引字段或索引描述 加 `_idx` 如：`sex_idx`. 



29、数据库设计规范：

- 注释：注释主要包含了表注释与列注释。函数过程、触发器等在代码开头应有阐述。

- 数据库引擎只是用InnoDB。经常读写的，需要添加 自增/顺序 特征。

- 使用utf8编码格式。

- IP字段，ipv4选择使用 int 类型进行存储；ipv6使用varchar(40)进行存储。

- 手机号字段，国产号码可以使用 bigint 进行存储。

- 金额字段，统一采用`decimal(17,0)`类型，金额以“分”为单位保存.

- 时间字段优先选择 datetime。

- 精确浮点数字段必须使用decimal替代float和double

- 每张表为了便于分析，都需要添加两个辅助字段：

  ```java
  raw_add_time timestamp DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  raw_update_time timestamp DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间'
  ```

- 禁止在数据库中使用 varbinary、blob、text存储图片。

- 禁止使用外键。

- 枚举类型可以使用 enum 类型。



30、数据库索引规范：

- 合理的使用索引。在程序的设计中，如果扫描的数据量操过了全表的30%，那么就会更改为全表扫描，耗时耗力。
- 非主键索引，执行update、delete的时候，会对索引进行更新操作，耗时更长。
- 单表的索引应该符合的规范：
  - 索引控制在5个左右，单个索引的字段不应该操作五个。
  - 不能够在主键上建立唯一索引。
  - 较长的字段需要通过前缀来减少索引长度，提升效率。
- **索引覆盖**：`InnoDB` 存储引擎中，`secondary index`（非主键索引）中没有直接存储行地址，而存储主键值. 如果用户需要查询`secondary index`中所不包含的数据列时，需要先通过`secondary index`查找到主键值，然后再通过主键查询到其他数据列，因此需要查询两次. 覆盖索引的概念就是查询可以通过在一个索引中完成，覆盖索引效率会比较高，主键查询是覆盖索引. 
- 尽量不要在索引上面试用 % 进行模糊查询。
- 对SQL语句，可以使用 EXPLAIN 进行SQL语句的合理性分析。
- 合理使用 limit 进行分页。
- 不要使用 * 作为需要查询的字段。
- 避免使用前缀模糊查询（like '%是'）以及 负向查询（not in、not exist等）
- 数据库事务是即开即用，用完关闭，与事务无关的操作。放到事务外进行执行，减少资源限制。
- 在条件三个及三个以上的时候，使用union比 or 更加高效。



31、数据库基本优化策略：

- 减少数据访问--合理创建索引、使用索引、使用覆盖索引、优化SQL执行计划。
- 返回更少数据---进行合理的分页、只返回合理的字段。
- 减少交互次数---批量提交，合并查询条件，设置 Fetch size(每次返回的记录数)。
- 减少CPU开销---使用绑定变量(对变化的纸采用变量参数的形式提交)、避免运算、减少特殊比较(例如：减少 in 、like关键字的使用)。







32、日志级别：

- debug：用于调试、运行轨迹追踪
- info（默认）：打印基本业务完整性日志，服务的入口、出口等。
- warn：表示可能存在的问题，以及重要的提示。
- error：业务处理出错或者致命日志。

33、日志类型：

- 查询日志(非必须的)：

  > 业务性能日志,日志名前缀为 {appName}-query
  >
  > 可以把查询相关的请求日志写入到一个文件中，方便日志定位。

- 摘要日志(必须的)：

  > 业务摘要日志，记录业务执行轨迹。
  >
  > 摘要日志请使用`com.yjf.common.log.DL`工具类输出日志。

- 性能日志(非必须的)：

  > 业务性能日志,日志名前缀为 `{appName}-perf`
  >
  > 性能日志主要标识了从两个时间点的执行时间来测量某业务的性能情况
  >
  > 业务性能日志建议使用[perf4j](https://github.com/perf4j/perf4j)

34、日志保存策略：

- 日志最长保存时间为 60 天。
- 保存形式：
  - 定期清理日志的关键字 [dt] ，如： 14dt.log
  - 定期备份日志的关键字 [de] ，如： 14de.log



35、代码中严禁使用 System.out.Println() 代码。

36、不能够提交IDE下面的 .classpath、target、.idea、*.iml 文件。



## 二、代码规范操作

### 1、数据校验

​	在程序的开发过程中，需要进行数据的校验操作。

#### 1）前端校验	

​	在数据的传输过程中，前端页面需要使用易极付数据校验统一规范进行数据的校验操作。其中主要有两个目的：

- 第一：能够有效的保证数据的安全性。
- 第二：能够统一规范前端后台的数据的格式。

#### 2）后端校验

​	在数据传输到后台以后，需要在后台进行数据的校验，主要是包含两层校验：

- 第一层：静态校验。

  - 后台得到数据以后，需要对数据进行合法性的校验操作，也是采用易极付的校验规则。
  - 接收的对象，需要启动易极付封装的JSR303校验。

- 第二层：

  **针对新增数据  的动态校验。**

  - 新查询，后插入（这种方式增加了数据库的计算能力，常用与分布式数据库）。
  - 创建数据库唯一索引，保证数据的原子性操作（常用）。	

  ```java
  //数据库中创建唯一索引，然后每次添加数据之前，将可能遇到唯一性异常，所以需要将这个代码放到唯一性异常的try中
  try {
      id = dataMainTenanceService.addData(cardData);
  } catch (DuplicateKeyException e) {
      //当出现唯一性异常以后，需要将那条数据查询出来，然后提交给前端页面，并返回错误信息
      CardData one = dataMainTenanceService.findOne(cardData.getId());
      model.addAttribute("carData",one);
      model.addAttribute("err_msg","数据库出现唯一性异常"+e);
      return "redirect:/toCardDataMainTenance";
  }
  ```

  **针对修改数据  的动态校验。**

  - 首先少不了静态校验。

  - 其次是调用悲观锁的方式，为需要修改的那一条数据上悲观锁，

    ​	使用的方式是：selectUpdate 来进行上锁的操作。